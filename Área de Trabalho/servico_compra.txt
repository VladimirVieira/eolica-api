package ecommerce.service;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import ecommerce.dto.CompraDTO;
import ecommerce.dto.DisponibilidadeDTO;
import ecommerce.dto.EstoqueBaixaDTO;
import ecommerce.dto.PagamentoDTO;
import ecommerce.entity.CarrinhoDeCompras;
import ecommerce.entity.Cliente;
import ecommerce.entity.ItemCompra;
import ecommerce.external.IEstoqueExternal;
import ecommerce.external.IPagamentoExternal;
import jakarta.transaction.Transactional;

@Service
public class CompraService {

	private final CarrinhoDeComprasService carrinhoService;
	private final ClienteService clienteService;

	private final IEstoqueExternal estoqueExternal;
	private final IPagamentoExternal pagamentoExternal;

	@Autowired
	public CompraService(CarrinhoDeComprasService carrinhoService, ClienteService clienteService,
			IEstoqueExternal estoqueExternal, IPagamentoExternal pagamentoExternal) {
		this.carrinhoService = carrinhoService;
		this.clienteService = clienteService;

		this.estoqueExternal = estoqueExternal;
		this.pagamentoExternal = pagamentoExternal;
	}

	@Transactional
	public CompraDTO finalizarCompra(Long carrinhoId, Long clienteId) {
		Cliente cliente = clienteService.buscarPorId(clienteId);
		CarrinhoDeCompras carrinho = carrinhoService.buscarPorCarrinhoIdEClienteId(carrinhoId, cliente);

		 // Agrupando a coleta dos IDs e quantidades de produtos em um único loop-->alterei aqui
		List<Long> produtosIds = new ArrayList<>();
		List<Long> produtosQtds = new ArrayList<>();

		// Iterando sobre os itens no carrinho e coletando os IDs e as quantidades dos produtos
		for (ItemCompra item : carrinho.getItens()) {
		    produtosIds.add(item.getProduto().getId());  // Adicionando o ID do produto
		    produtosQtds.add(item.getQuantidade());  // Adicionando a quantidade do produto
		}

		// Verificando a disponibilidade dos produtos no estoque
		DisponibilidadeDTO disponibilidade = estoqueExternal.verificarDisponibilidade(produtosIds, produtosQtds);

		// Verificando se a resposta da disponibilidade é nula
		if (disponibilidade == null) {
		    throw new IllegalStateException("Falha ao verificar disponibilidade dos itens. Resposta do estoque está vazia.");
		}

		// Verificando se os itens estão disponíveis no estoque
		if (!disponibilidade.disponivel()) {
		    throw new IllegalStateException("Itens fora de estoque.");
		}

		// Calculando o custo total da compra
		BigDecimal custoTotal = calcularCustoTotal(carrinho);

		// Autorizando o pagamento com o valor calculado
		PagamentoDTO pagamento = pagamentoExternal.autorizarPagamento(cliente.getId(), custoTotal.setScale(2, RoundingMode.HALF_UP).doubleValue());

		// Verificando se o pagamento foi autorizado
		if (!pagamento.autorizado()) {
		    throw new IllegalStateException("Pagamento não autorizado.");
		}

		// Realizando a baixa no estoque após o pagamento autorizado
		EstoqueBaixaDTO baixaDTO = estoqueExternal.darBaixa(produtosIds, produtosQtds);

		// Verificando se a baixa no estoque foi bem-sucedida
		if (!baixaDTO.sucesso()) {
		    // Cancelando o pagamento caso a baixa no estoque falhe
		    pagamentoExternal.cancelarPagamento(cliente.getId(), pagamento.transacaoId());
		    throw new IllegalStateException("Erro ao dar baixa no estoque.");
		}

		// Criando o objeto CompraDTO com sucesso e a transação do pagamento
		CompraDTO compraDTO = new CompraDTO(true, pagamento.transacaoId(), "Compra finalizada com sucesso.");

		return compraDTO;
	}

	public BigDecimal calcularCustoTotal(CarrinhoDeCompras carrinho) {
		BigDecimal custoItens = carrinho.getItens().stream()
			.map(item -> item.getProduto().getPreco().multiply(BigDecimal.valueOf(item.getQuantidade())))
			.reduce(BigDecimal.ZERO, BigDecimal::add);

    	double pesoTotal = carrinho.getItens().stream()
			.mapToDouble(item -> item.getProduto().getPeso() * item.getQuantidade())
			.sum();

    	// Cálculo do valor do frete com base no peso
    	BigDecimal frete = calcularFrete(pesoTotal, carrinho.getCliente());

    	BigDecimal desconto = BigDecimal.ZERO;
    	if (custoItens.compareTo(BigDecimal.valueOf(1000)) > 0) {
			desconto = custoItens.multiply(BigDecimal.valueOf(0.2));
    	} else if (custoItens.compareTo(BigDecimal.valueOf(500)) > 0) {
			desconto = custoItens.multiply(BigDecimal.valueOf(0.1));
    	}

    BigDecimal custoItensComDesconto = custoItens.subtract(desconto);

    	// Cálculo do custo total (itens com desconto + frete)
    	return custoItensComDesconto.add(frete);
	}

	BigDecimal calcularFrete(double pesoTotal, Cliente cliente) {
		BigDecimal valorFrete;
		
		if (pesoTotal < 5) {
			valorFrete = BigDecimal.ZERO;
		}else if (pesoTotal <= 10) {
		    // Peso entre 5kg e 10kg: frete de R$ 2 por kg
		    valorFrete = BigDecimal.valueOf(pesoTotal * 2);
		} else if (pesoTotal <= 50) {
		    // Peso entre 10kg e 50kg: frete de R$ 4 por kg
		    valorFrete = BigDecimal.valueOf(pesoTotal * 4);
		} else{
		    // Peso superior a 50kg: frete de R$ 7 por kg
		    valorFrete = BigDecimal.valueOf(pesoTotal * 7);
		}


		// Aplicação de descontos no frete com base no tipo de cliente
		switch (cliente.getTipo()) {
			case OURO:
				valorFrete = BigDecimal.ZERO; // Isenção total
				break;
			case PRATA:
				valorFrete = valorFrete.multiply(BigDecimal.valueOf(0.5)); // 50% de desconto
				break;
			//case BRONZE:
			//	break; // Sem desconto adicional
			default:
				break; // Sem desconto adicional
		}

		return valorFrete;
	}
	
	
	
	
	

}
